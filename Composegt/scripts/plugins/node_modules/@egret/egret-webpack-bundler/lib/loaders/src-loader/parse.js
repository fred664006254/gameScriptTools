"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ts = __importStar(require("typescript"));
function hasModifier(node, kind) {
    return (node.modifiers || []).some(function (item) {
        if (item.kind === kind) {
            return true;
        }
        return false;
    });
}
function getExpression(node) {
    if (node.kind === ts.SyntaxKind.Identifier) {
        return node.text;
    }
    if (node.expression) {
        if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {
            var pre = getExpression(node.expression);
            if (typeof pre === 'string' && node.name) {
                return pre + "." + node.name.text;
            }
            return pre;
        }
        return node.expression; // 节点
    }
    return null;
}
function isBlockScope(node) {
    return ts.isBlockScope(node);
}
function forEachChild(node, callback) {
    var walk = function (child) {
        if (child.kind !== ts.SyntaxKind.TypeReference) { // 忽略类型检查
            var walkChildren = callback(child);
            if (!isBlockScope(child)) {
                if (Array.isArray(walkChildren)) {
                    walkChildren.forEach(walk);
                }
                else if (walkChildren !== false) {
                    ts.forEachChild(child, walk);
                }
            }
        }
    };
    ts.forEachChild(node, walk);
}
function collectNodeDeclarations(node, declarations) {
    var walkChildren = false;
    var addDeclarations = function (name, type) {
        declarations[name] = {
            type: type,
            ConstKeyword: hasModifier(node, ts.SyntaxKind.ConstKeyword),
            DeclareKeyword: hasModifier(node, ts.SyntaxKind.DeclareKeyword),
            ExportKeyword: hasModifier(node, ts.SyntaxKind.ExportKeyword),
        };
    };
    switch (node.kind) {
        case ts.SyntaxKind.VariableDeclaration:
            // ObjectBindingPattern ArrayBindingPattern
            if (Array.isArray(node.name.elements)) {
                node.name.elements.forEach(function (el) {
                    addDeclarations(el.name.text, 'Variable');
                });
            }
            else {
                addDeclarations(node.name.text, 'Variable');
            }
            break;
        case ts.SyntaxKind.VariableStatement:
            node.declarationList.declarations.forEach(function (declaration) {
                addDeclarations(declaration.name.text, 'Variable');
            });
            break;
        case ts.SyntaxKind.EnumDeclaration:
            addDeclarations(node.name.text, 'Enum');
            break;
        case ts.SyntaxKind.Parameter:
            if (Array.isArray(node.name.elements)) {
                node.name.elements.forEach(function (el) {
                    addDeclarations(el.name.text, 'Parameter');
                });
            }
            else {
                addDeclarations(node.name.text, 'Parameter');
            }
            break;
        case ts.SyntaxKind.FunctionDeclaration:
            addDeclarations(node.name.text, 'Function');
            break;
        case ts.SyntaxKind.InterfaceDeclaration:
            addDeclarations(node.name.text, 'Interface');
            break;
        case ts.SyntaxKind.ClassDeclaration:
            addDeclarations(node.name.text, 'Class');
            break;
        case ts.SyntaxKind.ModuleDeclaration:
            addDeclarations(node.name.text, 'Namespace');
            break;
        default:
            walkChildren = true;
            break;
    }
    return walkChildren;
}
function collectNodeDepenDencies(node, dependencies) {
    var walkChildren = false;
    var addDependency = function (name, type) {
        if (!/^(undefined|null)$/i.test(name)) {
            dependencies[name] = {
                type: type,
            };
        }
    };
    // 只简单的分析一下最外层的依赖
    switch (node.kind) {
        case ts.SyntaxKind.Identifier:
            if (node.parent.name !== node) { // 不能是别人的名字
                addDependency(node.text, 'Identifier');
            }
            break;
        case ts.SyntaxKind.PropertyAccessExpression:
            {
                var identifier = getExpression(node);
                if (typeof identifier === 'string') {
                    addDependency(identifier, 'PropertyAccess');
                }
                else if (identifier && identifier.kind) {
                    walkChildren = [identifier];
                }
            }
            break;
        case ts.SyntaxKind.ClassDeclaration:
            walkChildren = (node.members || [])
                .filter(function (item) { return hasModifier(item, ts.SyntaxKind.StaticKeyword); });
            (node.heritageClauses || []).forEach(function (clause) {
                (clause.types || []).forEach(function (cl) {
                    var expression = cl.expression;
                    var identifier = getExpression(expression);
                    if (typeof identifier === 'string') {
                        addDependency(identifier, 'Extend');
                    }
                    else if (identifier && identifier.kind) {
                        walkChildren.push(identifier);
                    }
                });
            });
            break;
        default:
            walkChildren = true;
            break;
    }
    return walkChildren;
}
function collectGlobals(scopes, dependencies) {
    var globals = {};
    Object.keys(dependencies).forEach(function (name) {
        var rootName = name.split('.')[0];
        var has = scopes.some(function (locals) {
            return !!locals[rootName];
        });
        if (!has && !globals[name]) {
            globals[name] = dependencies[name];
        }
    });
    return globals;
}
function collectDependencies(node, namespace, scopes) {
    if (namespace === void 0) { namespace = ''; }
    if (scopes === void 0) { scopes = []; }
    var locals = {};
    var dependencies = {};
    forEachChild(node, function (child) { return collectNodeDeclarations(child, locals); });
    forEachChild(node, function (child) { return collectNodeDepenDencies(child, dependencies); });
    var thisScopes = __spreadArrays([locals], scopes);
    var tmpGolbals = collectGlobals(thisScopes, dependencies);
    var globals = {};
    Object.keys(tmpGolbals).forEach(function (name) {
        globals["" + name + (namespace ? '@' + namespace.slice(0, -1) : '')] = tmpGolbals[name];
    });
    forEachChild(node, function (child) {
        var ns = namespace;
        if (isBlockScope(child)
            && !ts.isFunctionLike(child) // 函数里的依赖管不了，有很多循环依赖
        ) {
            if (ts.isModuleDeclaration(child)) {
                ns = "" + ns + child.name.text + ".";
            }
            Object.assign(globals, collectDependencies(child, ns, thisScopes));
        }
    });
    return globals;
}
function collectDefines(node, namespace) {
    if (namespace === void 0) { namespace = ''; }
    var declarations = {};
    forEachChild(node, function (child) { return collectNodeDeclarations(child, declarations); });
    var defines = {};
    Object.keys(declarations).forEach(function (key) {
        var item = declarations[key];
        if ((!namespace || item.ExportKeyword)
            && !item.DeclareKeyword
            && item.type !== 'Interface'
            && (item.type !== 'Enum' || !item.ConstKeyword)) {
            defines["" + namespace + key] = {
                type: item.type,
            };
        }
    });
    // 收集namespace
    forEachChild(node, function (child) {
        if (ts.isModuleDeclaration(child)) {
            Object.assign(defines, collectDefines(child, "" + namespace + child.name.text + "."));
        }
    });
    return defines;
}
function judgeIsModule(node) {
    var ret = false;
    forEachChild(node, function (child) {
        if (hasModifier(child, ts.SyntaxKind.ExportKeyword)
            || child.kind === ts.SyntaxKind.ImportDeclaration) {
            ret = true;
        }
    });
    return ret;
}
function fn(fileName, content) {
    // AST 语法树
    var sourceFile = ts.createSourceFile(fileName, content, ts.ScriptTarget.ES2015, true);
    var isModule = judgeIsModule(sourceFile);
    var defines = collectDefines(sourceFile);
    var dependencies = collectDependencies(sourceFile);
    return {
        isModule: isModule,
        defines: defines,
        dependencies: dependencies,
    };
}
exports.default = fn;
